---
title: 智能合约
description:
keywords:
  - 智能合约选项
  - WebAssembly
  - Solidity
  - ink!
  - Wasm
---

如[决定构建什么](/design/decide-what-to-build/)中所述，智能合约是在基于 Substrate 的区块链上运行应用程序的一种方法。
虽然存在某些限制，但智能合约也有一些优点。
例如，你可能希望从智能合约开始构建项目的一个原因是，合约通常可以快速开发和测试，使你能够快速迭代设计决策并将应用程序更快地投放到市场。

通常，你可以在 Substrate 运行时中部署两种类型的智能合约：

- WebAssembly 合约。
- 与 EVM 兼容的合约。

你想要构建的合约类型是你需要做的第一个决定之一。
同样重要的是要注意，智能合约是使用特定链地址（智能合约帐户地址）实例化和执行的指令。
这意味着除了选择编写智能合约的语言外，你还需要确定将作为合约主机平台的链。
例如，你可能希望将你的应用程序部署为 Polkadot 或 Kusama 生态系统中现有平行链上的智能合约，与其他团队合作构建专门用于你想要部署的合约类型的自定义平行链，或者使用你想要提供的特定功能和功能构建你自己的运行时。

## 关于合约模块

在大多数情况下，如果你想为 Substrate 运行时构建智能合约，合约模块是最佳选择。
通过将合约模块添加到运行时，你可以部署和执行基于 WebAssembly 的智能合约。
如果你正在构建自己的运行时来托管智能合约，则包含合约模块有两个主要原因：

- 你想要构建一个通用区块链，该区块链使用智能合约来提供你想要提供的**核心功能**。

  例如，如果你有一个专注于使用智能合约的创新想法，则可以使用合约模块来构建链的基础层，然后仅使用实现应用程序特定目标所需的最小数量的其他模块来补充基础层。

- 你想要构建一个具有使用智能合约与链交互的**灵活性**的特定于应用程序的区块链。

  例如，如果你正在构建一个使用其他 Substrate 模块定义的大部分逻辑的链，则可以通过智能合约向用户公开链逻辑的某些部分。
  智能合约非常适合此类用例，因为它们将所有用户输入视为不受信任的和潜在的对抗性的。

  例如，假设你正在构建一个去中心化交易所。
  大部分逻辑都在模块中定义，但你希望允许用户通过智能合约上传他们自己的交易算法。
  使用与执行智能合约相关的燃气费，用户必须为其交易算法的执行时间付费。

  合约模块为此功能和编程语言（如 [ink!](https://paritytech.github.io/ink/)）提供了[链扩展](https://ink.substrate.io/macros-attributes/chain-extension/) 原语，可以使用你的链公开的业务逻辑原语。

## 智能合约帐户

合约模块基于 `Currency` 特性扩展帐户以具有智能合约功能。
你可以使用这些**智能合约帐户**来实例化智能合约并向其他合约和非合约帐户发出调用。

智能合约代码存储在缓存中，可以使用其哈希检索。
此设计使多个智能合约可以从相同的哈希实例化，而无需每次都复制代码。

当用户通过调用智能合约的某个函数来与智能合约交互时，将使用代码哈希检索关联的智能合约代码，并执行该函数。
调用智能合约函数可能会导致：

- 更改与智能合约帐户关联的存储。
- 更改与非合约帐户关联的存储。
- 实例化新的智能合约。
- 调用另一个智能合约帐户。

如果智能合约帐户已用尽，则其关联的代码和存储也将被删除。

## 合约执行和燃气

智能合约调用的所有指令都需要以**燃气**费用的形式支付。
发送者必须为每次调用指定燃气限制。
无论执行结果如何，未使用的燃气都会在调用后退还。

如果达到燃气限制，则所有调用和状态更改（包括余额转移）都只会在当前调用的合约级别回滚。
例如，如果合约 A 调用合约 B，而合约 B 在调用过程中用尽了燃气，则所有合约 B 调用和状态更改都会回滚。
如果合约 A 具有正确的错误处理，则合约 A 做出的任何其他调用和状态更改都会保留。
