---
title: 交易和区块基础知识
description: 描述用于创建区块的交易类型以及区块的基本组件。
keywords:
---

在本文中，您将了解可以创建的不同类型的交易，以及如何在运行时中使用它们。
总的来说，交易决定了进入区块链中区块的数据。
通过了解不同交易类型的使用方式，您将能够更好地为您的需求选择合适的类型。

## 什么是交易？

一般来说，交易提供了一种机制，用于对可以包含在区块中的状态进行更改。
Substrate 中有三种不同的交易类型：

- [签名交易](#signed-transactions)
- [未签名交易](#unsigned-transactions)
- [内在交易](#inherent-transactions)

在 Substrate 中，所有三种交易类型通常更广泛地称为**外部函数**。
术语外部函数通常用于表示源自运行时外部的任何信息。

但是，出于实际目的，独立考虑每种交易类型并识别每种类型最适用的场景更有用。

### 签名交易

签名交易必须包含发送传入请求以执行某些运行时调用的账户的签名。
通常，使用提交请求的账户的私钥对请求进行签名。
在大多数情况下，提交请求的账户还会支付交易费用。但是，交易费用和交易处理的其他要素取决于运行时逻辑的定义方式。

签名交易是最常见的交易类型。
例如，假设您有一个账户，其中包含一些代币。
如果您想将代币转移给 Alice，则可以调用 Balances 模块中的 `pallet_balances::Call::transfer` 函数。
由于您的账户用于进行此调用，因此您的账户密钥用于对交易进行签名。
作为请求者，您通常需要支付费用才能处理您的请求。
或者，您也可以给区块生成者小费，以提高您的交易优先级。

### 未签名交易

未签名交易不需要签名，也不包含任何关于谁提交了交易的信息。

对于未签名交易，没有经济上的威慑力来防止垃圾邮件或重放攻击。
您必须定义验证未签名交易的条件以及保护网络免受滥用和攻击所需的逻辑。
由于未签名交易需要自定义验证，因此这种交易类型比签名交易消耗更多资源。

`pallet_im_online::Call::heartbeat` 函数使用未签名交易来使验证者节点能够向网络发送信号，以表明该节点在线。
此函数只能由在网络中注册为验证者的节点调用。
该函数包含内部逻辑来验证该节点是否为验证者，允许该节点使用未签名交易来调用该函数，以避免支付任何费用。

### 内在交易

内在交易（有时称为内在交易）是一种特殊的未签名交易类型。
使用这种类型的交易，区块生成节点可以直接将信息添加到区块中。
内在交易只能由调用它们的区块生成节点插入到区块中。
通常，这种类型的交易不会被闲聊到其他节点，也不会存储在交易队列中。
使用内在交易插入的数据被认为是有效的，无需进行特定验证。

例如，如果区块生成节点将时间戳插入到区块中，则无法证明时间戳是准确的。
相反，验证者可能会根据时间戳是否在其自身系统时钟的某个可接受范围内来接受或拒绝区块。

例如，`pallet_timestamp::Call::now` 函数使区块生成节点能够在其生成的每个区块中插入当前时间戳。
类似地，`paras_inherent::Call::enter` 函数使平行链验证者节点能够将其验证数据发送到其中继链，中继链期望收到这些数据。

## 什么是区块？

在 Substrate 中，区块由一个头和一个交易数组组成。
头包含以下属性：

- 区块高度
- 父哈希
- 交易根
- 状态根
- 摘要

所有交易都捆绑在一起，作为一系列要按运行时定义的方式执行的交易。
您将在[交易生命周期](/learn/transaction-lifecycle/)中了解有关交易排序的更多信息。
交易根是该交易序列的加密摘要。
此加密摘要有两个目的：

- 它防止在区块头构建和分发之后对交易序列进行任何更改。
- 它使轻客户端能够仅凭区块头的知识来简洁地验证任何给定交易是否存在于区块中。

## 下一步去哪里

现在您已经熟悉了交易类型以及构成区块的信息，请探索以下主题以了解更多信息。

- [交易生命周期](/learn/transaction-lifecycle/)
- [状态转换和存储](/learn/state-transitions-and-storage/)
- [交易、权重和费用](/build/tx-weights-fees/)
- [交易格式](/reference/transaction-format/)
- [区块参考](https://paritytech.github.io/substrate/master/sp_runtime/traits/trait.Block.html)
